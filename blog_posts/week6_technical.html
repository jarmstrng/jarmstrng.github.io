<!DOCTYPE html>
<html lang=”en”>
  <head>
    <meta charset=”utf-8”>
    <title>Happy Blog Times</title>
  </head>
  <body>
    <h1>Ruby's Object-Orientedness, Inheritance, Concurrency, Clojure, Software Transactional Memory, Functional Programming...</h1>

    <p>The assignment was to write about one of six different topics relevant to our coursework this week, each being variations on Ruby's take on Object-Oriented Programming (OOP).</p>

    <p>Instead of a straightforward path, though, I found myself on a long, convoluted journey to answer those questions that never leave me alone: Why? What are the implications? What are the alternatives?</p>

    <h2>The Rabbit Hole</h2> 
    <p>As a beginning programmer, the idea of object-orientedness is very new to me.</p>

    <p>Just two weeks ago I thought all programming was procedural, like following a recipe in a cookbook. When I first read and comprehended that Ruby does not have data (ingredients) in this little compartment and operations that can be performed on data (mixing, cooking) in this other, separate compartment, but instead has objects that hold both data and a knowledge of the operations that can be performed on that data - I thought it sounded like magic. How could this be so?</p>

    <p>This was the beginning of a whole new line of questioning.</p>

    <h4>Either the well was very deep, or she fell very slowly, for she had plenty of time as she went down to look about her and to wonder what was going to happen next.</h4>

    <p><em>Why the heck would anyone want object-orientedness in a programming language, anyway?</em></p>

    <p>It turns out "encapsulation" is one of the key benefits of object-oriented programming. Having separate little capsules of information, often called "modules" and "classes", helps prevent accidental accessing and alteration of data. It also allows for the re-use of code, which is efficient and makes it easier to maintain.</p>

    <p><em>Well, what do other languages do?</em></p>

    <p>This, unfortunately, is a wormhole of a question. The only correct answer might be: lots of things. There isn't agreement on exactly what object-oriented, functional, procedural, imperative, etc. programming paradigms look like, and not only is there disagreement on definitions, but very few languages are "pure" examples of only one kind of programming - most of them are a mix.</p> 

    <p>In fact, I made an absolutely ridiculous diagram based on <a href="http://en.wikipedia.org/wiki/Comparison_of_programming_paradigms#Main_paradigm_approaches" target="new">Wikipedia's paradigm comparison</a> table, and learned nothing from it other than the fact that I would have to come back to the question later, after I had learned much more.</p>

    <p>Object-orientedness doesn't even guarantee use of the aforementioned modules and classes, as some languages, like JavaScript, use "prototypes" to create inheritance...

    <p><em>So how does inheritance work?</em></p>

    <p>In Ruby, each object is a specific <em>kind</em> of object, as designated by its class. This works a little like the taxonomy of animals into kingdoms, etc., in biology. Bug would be a subclass of Invertebrate, and so bugs would all inherit the no-spine characteristics of invertebrates.</p>

    <p>Some languages allow a class to have multiple "parents" (multiple-inheritance), but this can create problems when parents have conflicting methods (methods being our "cooking actions" from the recipe example). To avoid this, Ruby requires single-inheritance, but then has modules that can be used in any number of different classes, in order to make sure classes can still share "actions."</p>

    <p><em>What's the difference between classes and modules?</em></p>

    <p>The important difference is that classes can create new objects, but modules can't - they just add functionality (the "actions" or operations).</p>

    <p><em>So classes and modules never have conflicting methods?</em></p>

    <p>There is a hierarchy of inheritance that prevents them from conflicting. If you want to "stir" the soup in your recipe, the computer first looks in the Soup class, and if it doesn't find "stir" there, it looks in any modules that have been connected to the Soup class. If it doesn't find it there, it looks in the parent class (Liquid, perhaps?), then in the parent class's connected modules, and so on. Move up the ladder checking the class first, then the module.</p>

    <p>To complicate matters, though, the latest version of Ruby has a new way to link classes and modules that tells the computer to look in the module <em>before</em> it looks in the class, instead of the other way around. Either way, though, there is a defined path that the computer uses to look for its instructions, so that you won't end up with any surprises.</p>

    <p><em>Surely there must be more brain-bending concepts in here?</em></p>

    <p>Why yes, yes there are. For one thing, since everything in Ruby is an object, classes and modules are objects too. They know the things that can be done with themselves. There is a Class class that knows what can be done with classes. AND, the Class class is a subclass of the Module class.  </p>

    <p>There is also an Object class (which means you can create an Object object, of all things). It is a subtype of the BasicObject class. The BasicObject class is so basic that it doesn't know much at all, and mostly exists so Object can exist. The Object class doesn't know much either, and relies on the Kernel <em>module</em> to hold a whole lot of that "basic" functionality that Ruby has as a language.</p>

    <p>As far as I can tell, knowing any of this is more an exercise in intellectual curiosity than something you can hang your coat on - not much practical benefit in having this knowledge as a beginner.</p>

    <h4>"I wonder how many miles I've fallen by this time?" Alice said aloud. "I must be getting somewhere near the centre of the earth."</h4>

    <p><em>So... is this really a good idea?</em></p>

    <p>Apparently there are some downsides to how Ruby's designed as a language. The most interesting one, to me, is that there is an increase in concurrency in programming these days, and that, plus the fact that data can be altered in Ruby, creates the potential for some bad things to happen.</p> 

    <p>Concurrency is like using multiple burners on your stove at the same time: you can cook your pasta on this burner, make a tasty sauce on this burner, and have a little greens with garlic and onions on this other burner, all at the same time. It's all one meal, but you're saving time cooking it on three burners instead of having to cook each thing one at a time because you only have one burner.</p> 

    <p>My little laptop has two cores (burners) and so it can multitask (cook this food and cook that food) when running a program (making dinner). Nowadays, there are online cloud services that effectively allow companies to rent hundreds or thousands of cores, so the company can compute a whole lot of data much faster than they could if they were only using however many computers they actually have in their building.</p>

    <p>The cooking metaphor pretty much breaks down here, but I'm going to stick with it to its absurdist end: the problem with concurrency in Ruby is that Ruby allows for another part of the program to potentially switch out the pasta (alter the data) while you're cooking it. You might finish cooking everything and then realize you now have half-cooked rice to eat with your grapefruit-tomato sauce and steamed pickles. Some languages, though, don't allow you to alter your data - they just create a new bit of data for you to work with - so that you won't have to worry about this problem.</p>

    <p>Of course, plenty of people like to use Ruby so there are <a href="http://www.slideshare.net/CharlesNutter/bringing-concurrency-to-ruby-rubyconf-india-2014" target="new">actions being taken</a> to make concurrency work better. (More on this in a second.)</p>

    <p><em>Well what's an alternative, then? What does that look like?</em></p>

    <p>One of the many languages that are an alternative to Ruby is Clojure, a functional language that that you might consider a godchild of the language Lisp. It was explicitly designed to do concurrency well. To prevent unintended consequences it does not allow data to be altered (it makes a copy and alters that), and it uses "software transactional memory," which is a fancy way of saying it keeps track of the changes to the (copies of) data - a "memory" of the "transactions." This works much like git or GitHub, which track the changes made to different versions of a program, as opposed to keeping copies of the different versions themselves.</p>

    <p>This idea of tracking differences is what is being implemented in JRuby to improve concurrency in Ruby, as linked to above.</p>

    <p><em>But what is this "functional" programming?</em></p>

    <p>Clojure is an example of a functional language so it emphasises mathematical functions (the actions). (Though of course it is not purely functional - like mentioned earlier, most modern languages take inspiration from multiple programming paradigms.)</p> 

    <p>In object-oriented programming, you have the ability to say <strong>x = 1 + 1</strong>, and the output will be different - on a certain level, anyway - from <strong>y = 1 + 1</strong>, because you have created two different "objects," <strong>x</strong> and <strong>y</strong>. (This is an oversimplification.) The focus is on objects.</p> 

    <p>Functional languages will instead focus on the <em>adding</em> function, so when a Clojure program says: <strong>(+ 1 1)</strong> you will always get the same output. This helps prevent unintended side effects.</p>

    <p><em>Wait, what was that crazy thing going on in the parentheses?</em></p>

    <p>Yes, I said <strong>(+ 1 1)</strong>. Clojure takes an approach to syntax that involves first listing the function (addition) and then the "arguments" it's going to act upon (1 and 1). The parentheses are used like you used them in math class for determining the order of operations, where <strong>1 + (1 / 2) = 1.5</strong>, but <strong>(1 + 1)/ 2 = 1</strong>.</p>

    <h4>"Well!" thought Alice to herself, "after such a fall as this, I shall think nothing of tumbling down stairs!"</h4>

    <p>

  </body>
</html>
